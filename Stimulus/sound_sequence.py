import numpy as np
from scipy.signal import resample
from scipy.io import wavfile
from core import Sequence
import sounddevice as sd
import os


class SoundSequence:
    """

    Class that can contain a sequence of sound events as audio. Construct it by passing it a list of stimulus onsets,
    for instance:

    sequence = Sequence.generate_isochronous(n=10, ioi=500)
    sound_sequence = SoundSequence(sequence.onsets)

    or:

    sound_sequence = SoundSequence([0, 500, 1000, 1500])

    Attributes
    ----------

    dtype : numpy.dtype object
        The dtype that has been read from the stimulus wav file. Will also be used in the output wav file.
    fs : int
        The sampling frequency of the sequence. Is set when stimulus is loaded.
    stim : NumPy 1D array
        Contains the samples of the loaded stimulus file.
    audio : NumPy 1D array
        Contains the samples of the output wav file, as generated by the generate_audio method.

    Methods
    -------
    load_stim_from_wav(wav_filepath, new_fs=None)
        Load a stimulus .wav file.
    generate_audio()
        Generate a sequence where each event is replaced by the stimulus file.
    write_wav(out_path)
        Write generated audio to a .wav file.
    """

    def __init__(self, onsets):
        if any(i < 0 for i in np.diff(onsets)):
            raise ValueError("The provided onsets are not spaced linearly in time. Check onset values.")
        else:
            self.onsets = onsets
        self.dtype = None  # The type of data that is read from the wav file (e.g. int16, will also be the output dtype)
        self.fs = None  # The sampling frequency of the stim file and therefore of the output file
        self.stim = None  # The stim loaded by the load_stim_from_wav function
        self.audio = None  # The output audio

    def load_stim_from_wav(self, wav_filepath, new_fs: int = None):
        """

        This function loads a stimulus for use with, for instance, the write_wav function.

        Parameters
        ----------
        wav_filepath : str or Path object
            The path to the wave file
        new_fs : int
            If resampling is required, you can provide the target sampling frequency

        Returns
        ----------
        Does not return anything. The loaded stimulus is stored in Sequence.stim .

        """

        # Read in the sampling frequency and all the samples from the wav file
        file_fs, samples = wavfile.read(wav_filepath)

        if len(np.shape(samples)) > 1:
            print("Input file was stereo. Please convert to mono first.")

        # Change dtype so we always have float32
        # todo check whether this works.
        if samples.dtype == 'int16':
            samples = np.cast['float32'](samples)
            samples /= 32768
        elif samples.dtype == 'int32':
            samples = np.cast['float32'](samples)
            samples /= 2147483648
        elif samples.dtype == 'float32':
            pass
        else:
            print("Unknown dtype for wav file. Check out scipy documentation here:")
            print("https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.wavfile.read.html")

        if new_fs is None or new_fs == file_fs:
            self.stim = samples
            self.fs = file_fs
        elif new_fs != file_fs:
            resample_factor = float(new_fs) / float(file_fs)
            resampled = resample(samples, int(len(samples) * resample_factor))
            self.stim = resampled
            self.fs = new_fs
        else:
            print("Error occurred when comparing sampling frequencies.")

    def make_audio(self):
        """
        This function generates a Numpy 1D array containing the samples of a sequence that is generated
        on the basis of the onsets and the loaded stim, then stores it to Sequence.audio .
        """

        # Check whether stimuli are not going to overlap (which happens when event is shorter than shortest difference
        # between two onsets.
        if any(x < len(self.stim) / self.fs * 1000 for x in np.diff(self.onsets)):
            raise ValueError("The length of the stimulus is longer than one of the IOIs. The events will overlap: "
                             "either use different onset values, or use a shorter stimulus sound.")

            # Check whether stimulus has been loaded
        if self.stim is None:
            print("Load stimulus first via load_stim_from_wav")
        else:
            # Generate an array of silence that has the length of all the onsets + one final stimulus
            # The dtype is important, because that determines the values that the magnitudes can take.
            array_length = (max(self.onsets) / 1000 * self.fs) + len(self.stim)
            audio = np.zeros(int(array_length), dtype=self.dtype)

            # loop over the onsets, calculate the position of the first sample (onset * self.fs) and replace
            for onset in self.onsets:
                start_pos = int(onset * self.fs / 1000)
                end_pos = int(start_pos + len(self.stim))
                audio[start_pos:end_pos] = self.stim

            self.audio = audio

    def make_stim(self, freq=400, duration=50, osc='sin', onramp=10, offramp=10):
        pass

    def load_audio(self):
        pass

    # MANIPULATION

    def resample_audio(self, new_fs):
        pass

    def increase_stim_gain(self, amount):
        pass

    def decrease_stim_gain(self, amount):
        pass

    def increase_stim_pitch(self, amount):
        pass

    def decrease_stim_pitch(self, amount):
        pass

    def set_stim_pitch(self, new_frequency):
        pass

    # OUTPUT

    def play(self):
        sd.play(self.audio, self.fs)

    def stop(self):
        sd.stop()

    def get_fs(self):
        pass

    def get_duration(self):
        pass

    def write_wav(self, out_path):
        """

        Writes the audio that has been generated using Sequence.generate_audio to disk as a wave file.

        Parameters
        ----------
        out_path : str or Path object
            The location where to save the .wav file.

        Returns
        -------
        Does not return anything.

        """
        if self.audio is None:
            print("Generate audio first via generate_audio")
        else:
            wavfile.write(filename=out_path, rate=self.fs, data=self.audio)

    def write_ogg(self, out_path):
        pass

    def write_json(self, out_path):
        pass
