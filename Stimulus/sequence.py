import numpy as np
from scipy.io import wavfile
from scipy.signal import resample
from pathlib import Path
import matplotlib.pyplot as plt


class Sequence:
    """
    Sequence class that can be used for generating random or isochronous sequences of IOIs and onsets.

    You can provide the IOIs yourself as a list as such:
        sequence = Sequence([500, 400, 600, 500]),
    or you can use one of the class methods for generating the IOIs:
        sequence = Sequence.generate_isochronous(n=10, ioi=500)

    Attributes
    ----------

    iois : list of integers
        A list of the sequence's inter-onset intervals.
    stats : dict
        A dictionary containing some useful statistics about the generated IOIs.
    onsets : list of numpy.int64's
        A list of the events' onset values (i.e. t values). t=0 is additionally added.
    dtype : numpy.dtype object
        The dtype that has been read from the stimulus wav file. Will also be used in the output wav file.
    fs : int
        The sampling frequency of the sequence. Is set when stimulus is loaded.
    stim : NumPy 1D array
        Contains the samples of the loaded stimulus file.
    audio : NumPy 1D array
        Contains the samples of the output wav file, as generated by the generate_audio method.

    Methods
    -------
    generate_random_normal(n, mu, sigma, rng=None)
        Generate a random sequence using the normal distribution.
    generate_random_uniform(n, a, b, rng=None)
        Generate a random sequence using a uniform distribution.
    generate_random_poisson(n, lam, rng=None)
        Generate a random sequence using a Poisson distribution.
    generate_random_exponential(n, lam, rng=None)
        Generate a random sequence using an exponential distribution.
    generate_isochronous(n, ioi)
        Generate an isochronous sequence using an exponential distribution.
    load_stim_from_wav(wav_filepath, new_fs=None)
        Load a stimulus .wav file.
    generate_audio()
        Generate a sequence where each event is replaced by the stimulus file.
    write_wav(out_path)
        Write generated audio to a .wav file.
    plot_audio()
        Plot the generated audio where the event onsets are on the x axis.

    """

    def __init__(self, iois):
        self.iois = np.array(iois)
        self.stats = {
            'ioi_mean': np.mean(self.iois),
            'ioi_median': np.median(self.iois),
            'ioi_q1': np.quantile(self.iois, 0.25),
            'ioi_q2': np.quantile(self.iois, 0.5),
            'ioi_q3': np.quantile(self.iois, 0.75),
            'ioi_sd': np.std(self.iois),
            'ioi_min': np.min(self.iois),
            'ioi_max': np.max(self.iois)
        }
        self.onsets = np.cumsum(np.append(0, iois))  # The onsets calculated from the IOIs.
        self.dtype = None  # The type of data that is read from the wav file (e.g. int16, will also be the output dtype)
        self.fs = None  # The sampling frequency of the stim file and therefore of the output file
        self.stim = None  # The stim loaded by the load_stim_from_wav function
        self.audio = None  # The output audio

    @classmethod
    def generate_random_normal(cls, n: int, mu: int, sigma: int, rng=None):
        """

        Class method that generates a sequence of random inter-onset intervals based on the normal distribution.
        Note that there will be n-1 IOIs in a sequence.

        Parameters
        ----------
        n : int
            The desired number of events in the sequence.
        mu : int
            The mean of the normal distribution.
        sigma : int
            The standard deviation of the normal distribution.
        rng : numpy.random.Generator, optional
            A Generator object, e.g. np.default_rng(seed=12345)

        Returns
        -------
        Returns an object of class Sequence.

        """
        if rng is None:
            rng = np.random.default_rng()

        round_iois = np.round(rng.normal(loc=mu, scale=sigma, size=n))

        return cls(round_iois)

    @classmethod
    def generate_random_uniform(cls, n: int, a: int, b: int, rng=None):
        """

        Class method that generates a sequence of random inter-onset intervals based on a uniform distribution.
        Note that there will be n-1 IOIs in a sequence.

        Parameters
        ----------
        n : int
            The desired number of events in the sequence.
        a : int
            The left bound of the uniform distribution.
        b : int
            The right bound of the normal distribution.
        rng : numpy.random.Generator, optional
            A Generator object, e.g. np.default_rng(seed=12345)

        Returns
        -------
        Returns an object of class Sequence.

        """
        if rng is None:
            rng = np.random.default_rng()

        round_iois = np.round(rng.uniform(low=a, high=b, size=n))

        return cls(round_iois)

    @classmethod
    def generate_random_poisson(cls, n: int, lam: int, rng=None):
        """

        Class method that generates a sequence of random inter-onset intervals based on a Poisson distribution.
        Note that there will be n-1 IOIs in a sequence.

        Parameters
        ----------
        n : int
            The desired number of events in the sequence.
        lam : int
            The desired value for lambda.
        rng : numpy.random.Generator, optional
            A Generator object, e.g. np.default_rng(seed=12345)

        Returns
        -------
        Returns an object of class Sequence.

        """
        if rng is None:
            rng = np.random.default_rng()

        round_iois = np.round(rng.poisson(lam=lam, size=n))

        return cls(round_iois)

    @classmethod
    def generate_random_exponential(cls, n: int, lam: int, rng=None):
        """

        Class method that generates a sequence of random inter-onset intervals based on an exponential distribution.
        Note that there will be n-1 IOIs in a sequence.

        Parameters
        ----------
        n : int
            The desired number of events in the sequence.
        lam : int
           The desired value for lambda.
        rng : numpy.random.Generator, optional
            A Generator object, e.g. np.default_rng(seed=12345)

        Returns
        -------
        Returns an object of class Sequence.

        """
        if rng is None:
            rng = np.random.default_rng()

        round_iois = np.round(rng.exponential(scale=lam, size=n))

        return cls(round_iois)

    @classmethod
    def generate_isochronous(cls, n: int, ioi: int):
        """

        Class method that generates a sequence of isochronous inter-onset intervals.
        Note that there will be n-1 IOIs in a sequence.


        Parameters
        ----------
        n : int
            The desired number of events in the sequence.
        ioi : int
            The inter-onset interval to be used between all events.

        Returns
        -------
        Returns an object of class Sequence.

        """

        return cls(np.round([ioi] * n))

    def load_stim_from_wav(self, wav_filepath, new_fs: int = None):
        """

        This function loads a stimulus for use with, for instance, the write_wav function.

        Parameters
        ----------
        wav_filepath : str or Path object
            The path to the wave file
        new_fs : int
            If resampling is required, you can provide the target sampling frequency

        Returns
        ----------
        Does not return anything. The loaded stimulus is stored in Sequence.stim .

        """

        # Read in the sampling frequency and all the samples from the wav file
        file_fs, samples = wavfile.read(wav_filepath)
        # We need the read dtype later on when we write the output wav (will be the same as the stim wav)
        self.dtype = samples.dtype

        if new_fs is None or new_fs == file_fs:
            self.stim = samples
            self.fs = file_fs
        elif new_fs != file_fs:
            resample_factor = float(new_fs) / float(file_fs)
            resampled = resample(samples, int(len(samples) * resample_factor))
            self.stim = resampled
            self.fs = new_fs
        else:
            print("Error occurred when comparing sampling frequencies.")

    def generate_audio(self):
        """
        This function generates a Numpy 1D array containing the samples of a sequence that is generated
        on the basis of the onsets and the loaded stim, then stores it to Sequence.audio .
        """

        # Check whether stimulus has been loaded
        if self.stim is None:
            print("Load stimulus first via load_stim_from_wav")
        else:
            # Generate an array of silence that has the length of all the onsets + one final stimulus
            # The dtype is important, because that determines the values that the magnitudes can take.
            array_length = (max(self.onsets) / 1000 * self.fs) + len(self.stim)
            audio = np.zeros(int(array_length), dtype=self.dtype)

            # loop over the onsets, calculate the position of the first sample (onset * self.fs) and replace
            for onset in self.onsets:
                start_pos = int(onset * self.fs / 1000)
                end_pos = int(start_pos + len(self.stim))
                audio[start_pos:end_pos] = self.stim

            self.audio = audio

    def write_wav(self, out_path):
        """

        Writes the audio that has been generated using Sequence.generate_audio to disk as a wave file.

        Parameters
        ----------
        out_path : str or Path object
            The location where to save the .wav file.

        Returns
        -------
        Does not return anything.

        """
        if self.audio is None:
            print("Generate audio first via generate_audio")
        else:
            wavfile.write(filename=out_path, rate=self.fs, data=self.audio)

    def plot_audio(self):
        """
        Plots the audio generated using Sequence.generate_audio with x-axis labels for each of the stimulus onsets.
        """
        if self.audio is None:
            print("Generate audio first via generate_audio")
        else:
            frames = np.arange(self.audio.size)  # x-axis
            plt.plot(frames, self.audio)  # x + y axis
            plt.xticks(ticks=self.onsets * self.fs / 1000,  # location of the ticks
                       labels=np.int_(self.onsets),  # labels of the ticks (rounded)
                       fontsize=8)
            plt.xlabel("Onsets (ms)")
            plt.show()


# Example usage
if __name__ == "__main__":
    # Manually input the IOIs and print onsets
    sequence = Sequence([500, 400, 600])
    print(sequence.onsets)

    # Get dictionary with descriptive statistics for the generated IOIs
    print(sequence.stats)
    print(sequence.stats['ioi_sd'])

    # Generate an isochronous sequence and print IOIs
    sequence = Sequence.generate_isochronous(n=10, ioi=500)
    print(sequence.iois)

    # Generate a random sequence using a normal distribution and print onsets
    sequence = Sequence.generate_random_normal(n=10, mu=500, sigma=20)
    print(sequence.onsets)

    # Load a stimulus from a wav file and generate a sequence of stimuli
    sequence = Sequence.generate_isochronous(n=10, ioi=500)
    sequence.load_stim_from_wav('click01.wav')
    sequence.generate_audio()
    sequence.write_wav('sequence.wav')

    # Resample input stimulus when loading
    sequence = Sequence([500, 500, 500, 500])
    sequence.load_stim_from_wav('click01.wav', new_fs=48000)
    sequence.generate_audio()
    sequence.write_wav('sequence_48000.wav')  # Output has same sampling frequency as input stimulus

    # We can also plot the wave file
    sequence = Sequence.generate_random_normal(n=10, mu=500, sigma=20)
    sequence.load_stim_from_wav('click01.wav')
    sequence.generate_audio()
    sequence.plot_audio()